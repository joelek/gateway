// This file was auto-generated by @joelek/autoguard. Edit at own risk.

import * as autoguard from "@joelek/autoguard/dist/lib-shared";
import { BitString } from "../../asn1";
import { ECCurve } from "../../pkcs8";
import { Integer } from "../../asn1";
import { OctetString } from "../../asn1";
import { Sequence } from "../../asn1";

export const ASN1BitString: autoguard.serialization.MessageGuard<ASN1BitString> = autoguard.guards.Reference.of(() => BitString);

export type ASN1BitString = autoguard.guards.Reference<BitString>;

export const ASN1Integer: autoguard.serialization.MessageGuard<ASN1Integer> = autoguard.guards.Reference.of(() => Integer);

export type ASN1Integer = autoguard.guards.Reference<Integer>;

export const ASN1OctetString: autoguard.serialization.MessageGuard<ASN1OctetString> = autoguard.guards.Reference.of(() => OctetString);

export type ASN1OctetString = autoguard.guards.Reference<OctetString>;

export const ASN1Sequence: autoguard.serialization.MessageGuard<ASN1Sequence> = autoguard.guards.Reference.of(() => Sequence);

export type ASN1Sequence = autoguard.guards.Reference<Sequence>;

export const ECPrivateKey: autoguard.serialization.MessageGuard<ECPrivateKey> = autoguard.guards.Intersection.of(
	autoguard.guards.Reference.of(() => ASN1Sequence),
	autoguard.guards.Object.of({
		"data": autoguard.guards.Tuple.of(
			autoguard.guards.Reference.of(() => ASN1Integer),
			autoguard.guards.Reference.of(() => ASN1OctetString),
			autoguard.guards.Object.of({
				"kind": autoguard.guards.StringLiteral.of("CONTEXT"),
				"form": autoguard.guards.StringLiteral.of("CONSTRUCTED"),
				"type": autoguard.guards.StringLiteral.of("END_OF_CONTENT"),
				"data": autoguard.guards.Tuple.of(
					autoguard.guards.Reference.of(() => ECCurve)
				)
			}, {}),
			autoguard.guards.Object.of({
				"kind": autoguard.guards.StringLiteral.of("CONTEXT"),
				"form": autoguard.guards.StringLiteral.of("CONSTRUCTED"),
				"type": autoguard.guards.StringLiteral.of("BOOLEAN"),
				"data": autoguard.guards.Tuple.of(
					autoguard.guards.Reference.of(() => ASN1BitString)
				)
			}, {})
		)
	}, {})
);

export type ECPrivateKey = autoguard.guards.Intersection<[
	autoguard.guards.Reference<ASN1Sequence>,
	autoguard.guards.Object<{
		"data": autoguard.guards.Tuple<[
			autoguard.guards.Reference<ASN1Integer>,
			autoguard.guards.Reference<ASN1OctetString>,
			autoguard.guards.Object<{
				"kind": autoguard.guards.StringLiteral<"CONTEXT">,
				"form": autoguard.guards.StringLiteral<"CONSTRUCTED">,
				"type": autoguard.guards.StringLiteral<"END_OF_CONTENT">,
				"data": autoguard.guards.Tuple<[
					autoguard.guards.Reference<ECCurve>
				]>
			}, {}>,
			autoguard.guards.Object<{
				"kind": autoguard.guards.StringLiteral<"CONTEXT">,
				"form": autoguard.guards.StringLiteral<"CONSTRUCTED">,
				"type": autoguard.guards.StringLiteral<"BOOLEAN">,
				"data": autoguard.guards.Tuple<[
					autoguard.guards.Reference<ASN1BitString>
				]>
			}, {}>
		]>
	}, {}>
]>;

export namespace Autoguard {
	export const Guards = {
		"ASN1BitString": autoguard.guards.Reference.of(() => ASN1BitString),
		"ASN1Integer": autoguard.guards.Reference.of(() => ASN1Integer),
		"ASN1OctetString": autoguard.guards.Reference.of(() => ASN1OctetString),
		"ASN1Sequence": autoguard.guards.Reference.of(() => ASN1Sequence),
		"ECPrivateKey": autoguard.guards.Reference.of(() => ECPrivateKey)
	};

	export type Guards = { [A in keyof typeof Guards]: ReturnType<typeof Guards[A]["as"]>; };

	export const Requests = {};

	export type Requests = { [A in keyof typeof Requests]: ReturnType<typeof Requests[A]["as"]>; };

	export const Responses = {};

	export type Responses = { [A in keyof typeof Responses]: ReturnType<typeof Responses[A]["as"]>; };
};
