"use strict";
// This file was auto-generated by @joelek/autoguard. Edit at own risk.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Autoguard = exports.PrivateKey = exports.PublicKey = exports.RSAPrivateKey = exports.RSAPublicKey = exports.RSAKey = exports.ECPrivateKey = exports.ECPublicKey = exports.ECKey = exports.AssymetricKey = exports.Key = exports.Curve = exports.KeyType = void 0;
const autoguard = require("@joelek/autoguard/dist/lib-shared");
var KeyType;
(function (KeyType) {
    KeyType[KeyType["EC"] = 0] = "EC";
    KeyType[KeyType["RSA"] = 1] = "RSA";
    KeyType[KeyType["oct"] = 2] = "oct";
})(KeyType = exports.KeyType || (exports.KeyType = {}));
;
(function (KeyType) {
    KeyType.Entries = [
        { key: "EC", value: 0 },
        { key: "RSA", value: 1 },
        { key: "oct", value: 2 }
    ];
    KeyType.Keys = autoguard.tables.createKeys(KeyType.Entries);
    KeyType.Values = autoguard.tables.createValues(KeyType.Entries);
    KeyType.KeyToValueMap = autoguard.tables.createKeyToValueMap(KeyType.Entries);
    KeyType.ValueToKeyMap = autoguard.tables.createValueToKeyMap(KeyType.Entries);
    KeyType.Key = autoguard.guards.Key.of(KeyType.KeyToValueMap);
    KeyType.Value = autoguard.guards.Key.of(KeyType.ValueToKeyMap);
    function keyFromValue(value) {
        return KeyType.ValueToKeyMap[KeyType.Value.as(value)];
    }
    KeyType.keyFromValue = keyFromValue;
    ;
    function valueFromKey(key) {
        return KeyType.KeyToValueMap[KeyType.Key.as(key)];
    }
    KeyType.valueFromKey = valueFromKey;
    ;
})(KeyType = exports.KeyType || (exports.KeyType = {}));
;
var Curve;
(function (Curve) {
    Curve[Curve["P-256"] = 0] = "P-256";
    Curve[Curve["P-384"] = 1] = "P-384";
    Curve[Curve["P-521"] = 2] = "P-521";
})(Curve = exports.Curve || (exports.Curve = {}));
;
(function (Curve) {
    Curve.Entries = [
        { key: "P-256", value: 0 },
        { key: "P-384", value: 1 },
        { key: "P-521", value: 2 }
    ];
    Curve.Keys = autoguard.tables.createKeys(Curve.Entries);
    Curve.Values = autoguard.tables.createValues(Curve.Entries);
    Curve.KeyToValueMap = autoguard.tables.createKeyToValueMap(Curve.Entries);
    Curve.ValueToKeyMap = autoguard.tables.createValueToKeyMap(Curve.Entries);
    Curve.Key = autoguard.guards.Key.of(Curve.KeyToValueMap);
    Curve.Value = autoguard.guards.Key.of(Curve.ValueToKeyMap);
    function keyFromValue(value) {
        return Curve.ValueToKeyMap[Curve.Value.as(value)];
    }
    Curve.keyFromValue = keyFromValue;
    ;
    function valueFromKey(key) {
        return Curve.KeyToValueMap[Curve.Key.as(key)];
    }
    Curve.valueFromKey = valueFromKey;
    ;
})(Curve = exports.Curve || (exports.Curve = {}));
;
exports.Key = autoguard.guards.Object.of({
    "kty": autoguard.guards.Reference.of(() => KeyType.Key)
}, {});
exports.AssymetricKey = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.Key), autoguard.guards.Object.of({
    "kty": autoguard.guards.Union.of(autoguard.guards.StringLiteral.of("EC"), autoguard.guards.StringLiteral.of("RSA"))
}, {}));
exports.ECKey = autoguard.guards.Object.of({
    "kty": autoguard.guards.StringLiteral.of("EC")
}, {});
exports.ECPublicKey = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ECKey), autoguard.guards.Object.of({
    "crv": autoguard.guards.Reference.of(() => Curve.Key),
    "x": autoguard.guards.String,
    "y": autoguard.guards.String
}, {}));
exports.ECPrivateKey = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.ECPublicKey), autoguard.guards.Object.of({
    "d": autoguard.guards.String
}, {}));
exports.RSAKey = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.AssymetricKey), autoguard.guards.Object.of({
    "kty": autoguard.guards.StringLiteral.of("RSA")
}, {}));
exports.RSAPublicKey = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.RSAKey), autoguard.guards.Object.of({
    "n": autoguard.guards.String,
    "e": autoguard.guards.String
}, {}));
exports.RSAPrivateKey = autoguard.guards.Intersection.of(autoguard.guards.Reference.of(() => exports.RSAPublicKey), autoguard.guards.Object.of({
    "d": autoguard.guards.String
}, {
    "p": autoguard.guards.String,
    "q": autoguard.guards.String,
    "dp": autoguard.guards.String,
    "dq": autoguard.guards.String,
    "qi": autoguard.guards.String,
    "oth": autoguard.guards.Array.of(autoguard.guards.Object.of({
        "r": autoguard.guards.String,
        "d": autoguard.guards.String,
        "t": autoguard.guards.String
    }, {}))
}));
exports.PublicKey = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ECPublicKey), autoguard.guards.Reference.of(() => exports.RSAPublicKey));
exports.PrivateKey = autoguard.guards.Union.of(autoguard.guards.Reference.of(() => exports.ECPrivateKey), autoguard.guards.Reference.of(() => exports.RSAPrivateKey));
var Autoguard;
(function (Autoguard) {
    Autoguard.Guards = {
        "Key": autoguard.guards.Reference.of(() => exports.Key),
        "AssymetricKey": autoguard.guards.Reference.of(() => exports.AssymetricKey),
        "ECKey": autoguard.guards.Reference.of(() => exports.ECKey),
        "ECPublicKey": autoguard.guards.Reference.of(() => exports.ECPublicKey),
        "ECPrivateKey": autoguard.guards.Reference.of(() => exports.ECPrivateKey),
        "RSAKey": autoguard.guards.Reference.of(() => exports.RSAKey),
        "RSAPublicKey": autoguard.guards.Reference.of(() => exports.RSAPublicKey),
        "RSAPrivateKey": autoguard.guards.Reference.of(() => exports.RSAPrivateKey),
        "PublicKey": autoguard.guards.Reference.of(() => exports.PublicKey),
        "PrivateKey": autoguard.guards.Reference.of(() => exports.PrivateKey)
    };
    Autoguard.Requests = {};
    Autoguard.Responses = {};
})(Autoguard = exports.Autoguard || (exports.Autoguard = {}));
;
